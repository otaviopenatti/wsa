/* ***************************************************************************
*    WSA source code is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    WSA source code is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with WSA source code. If not, see <http://www.gnu.org/licenses/>.
*
*    For commercial use of WSA source code, please contact me.
*
*    COPYRIGHT 2014  - Otavio A. B. Penatti - otavio_at_penatti_dot_com
* ************************************************************************** */

/* ***************************************************************************
*    This program refers to the implementation of the Word Spatial Arrangement (WSA)
*    method, which is described in detail in the following paper:
*       Visual word spatial arrangement for image retrieval and classification 
*       PENATTI, O. A. B. ; SILVA, F. B. ; VALLE, E. ; GOUET-BRUNET, V ; TORRES, R. da S. 
*       In: Pattern Recognition, volume 47, number 2, p. 705-720, 2014. 
* 
*     Bibtex:
*       @article{PenattiWSAPR2014,
*           author = {O. A. B. Penatti and  F. B. Silva and E. Valle and V. Gouet-Brunet and R. da S. Torres},
*           title = {Visual word spatial arrangement for image retrieval and classification},
*           journal = {Pattern Recognition},
*           volume = {47},
*           number = {2},
*           issn = {0031-3203},
*           year = {2014},
*           pages = {705-720}
*       }
* ************************************************************************** */

/* ***************************************************************************
DOCUMENTATION:
This program computes the WSA vectors for images in the input file.
The input file must have all points for all the images to be processed, one point at each line.
The points of a given image must be together (in consecutive lines).
The input file must be the resulting file of the coding step (e.g., hard or soft assignment).
The format of the input file is:
----------------
KEYPOINTS HARLAP.SIFT
6392
8696369
8000
ID IMAGE X Y A B C VECTOR
1 imgName1 x y a b c w1_id w1_act w5_id w5_act wN_id wN_act -1
2 imgName1 x y a b c w3_id w3_act w20_id w20_act wM_id wM_act -1
(...)

----------------
The first 5 lines (the header) have information about the dataset:
1st line --> always has the text "KEYPOINTS" followed by "DETECTOR.DESCRIPTOR", which refers to the point detector and descriptor used. 
             In the example above, we used Harris-Laplace detector and SIFT descriptor
2nd line --> number of images in the file
3rd line --> number of points in the file
4th line --> codebook size
5th line --> always has the text "ID IMAGE X Y A B C VECTOR"; this text indicates the values in each of the following lines. 

Each line after the header has the results of the coding step (e.g., hard or soft assingnment) for each point in the images of the file.
So, each line has the following fields (always separated by a single space):
    id --> numerical sequential id
    imgName --> image name
    x and y --> location of the point in the image
    a, b, and c --> other point information; e.g., scale, orientation, cornerness (if using the van de Sande program)
    wi_id, wi_act --> visual word id and its activation (separated by space), respectively; only non-zero activations appear; "-1" indicates the end of line

The output file generated by this program has the same format of the input file.
The difference is that each line will then correspond to the WSA vector of an image.
Hence, the output file has 'nImages' lines + 5 (header).

Running:
Simply run the program with no parameters for usage help.
./wsa <codebook_size> <input_file> <output_file>

* ************************************************************************** */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <time.h>

/* ***************************************************************************
Constants:
- IMG_NAME_SIZE: defines the maximum number of characters for the image name. In the input file, the image name is the second value in each line; 

- MAX_POINTS: defines the maximum number of points per image. As during the reading of the input file it is not possible to know 
              the number of points for the image that is being read, we allocate memory for MAX_POINTS points;
              You can adjust this constant for your dataset; The larger this value, the more memory will be used.

- N_QUADRANTS: defines the number of quadrants of WSA; DO NOT MODIFY IF YOU WANT TO USE THE ORIGINAL WSA VERSION (4 quadrants)

- THRESHOLD_SOFT: threshold for eliminating very low activations when using very soft assignments; Check the paper for details.

* ************************************************************************** */
#define IMG_NAME_SIZE 256
#define MAX_POINTS 22000  //parameter for the maximum number of points per image
#define N_QUADRANTS 4
#define THRESHOLD_SOFT 0.01  //to increment the quadrants counting, considers only activations greater than THRESHOLD_SOFT


//Structure for each line in the input file
typedef struct _point{
    long int id;
    char *imgName;
    double x, y, scale, b, c;
    double *assignment;
} Point;

//Auxiliar function
void printPoint(Point p, int fvDimension) {
    int i;
    printf("(POINT: %ld %s %lf ", p.id, p.imgName, p.x);
    if (p.x != -1) {
        printf(" %lf %lf %lf %lf", p.y, p.scale, p.b, p.c);
    }
    for (i=0; i<fvDimension; i++) {
        printf(" %lf", p.assignment[i]);
    }
    printf(")\n");
}

void copyPoint(Point *pDest, Point pOrig, int fvDimension) {
    int i;
    (*pDest).id = pOrig.id;
    strcpy((*pDest).imgName,pOrig.imgName);
    (*pDest).x = pOrig.x;
    (*pDest).y = pOrig.y;
    (*pDest).scale = pOrig.scale;
    (*pDest).b = pOrig.b;
    (*pDest).c = pOrig.c;
    for (i=0; i<fvDimension; i++) { //copy all the points values!
        (*pDest).assignment[i] = pOrig.assignment[i];
    }
}

int readPoint(FILE *keysFile, int fvDimension, Point *p) {
    int centerID, read;
    (*p).imgName = (char *) calloc(IMG_NAME_SIZE, sizeof(char));
    (*p).assignment = (double *) calloc(fvDimension, sizeof(double));
    //read point header (id imgName x)
    read = fscanf(keysFile, "%ld %s %lf", &(*p).id, (*p).imgName, &(*p).x);
    if ((*p).x == -1) { //image has no points
        return read;
    }
    //read point header (y a b c)
    read = fscanf(keysFile, "%lf %lf %lf %lf", &(*p).y, &(*p).scale, &(*p).b, &(*p).c);
    read = fscanf(keysFile, "%d", &centerID);
    while (centerID != -1 && read != EOF) {
        //centerID is the value before the assignment value
        //centerID starts from ONE!! goes from [1..k]
        read = fscanf(keysFile, "%lf", &(*p).assignment[(centerID-1)]); //read the assignment/activation value
        read = fscanf(keysFile, "%d", &centerID);  // read the next center id
    }
    return read;
}

Point *loadImagePoints(FILE *wordsFile, int fvDimension, Point *nextPoint, int *imgPoints) {
    //load all points from the current image
    //initially, nextPoint has no value! after the first image, nextPoint has the first point of the next image
    int read=-1, p;
    Point *points = (Point *) calloc(MAX_POINTS, sizeof(Point)); //create the vector of points... there may be many empty positions
    for (p=0; p<MAX_POINTS; p++) { //allocate the inner vectors
        points[p].imgName = (char *) calloc(IMG_NAME_SIZE, sizeof(char));
        points[p].assignment = (double *) calloc(fvDimension, sizeof(double));
    }

    //it is the first point ever; needs read something to it
    if ((*nextPoint).id==-11) {
        //free((*nextPoint).imgName);
        read = readPoint(wordsFile, fvDimension, nextPoint); //read new point to nextPoint
    }

    p = -1;
    //printPoint(*nextPoint, fvDimension);
    do {
        p++;
        copyPoint(&points[p], *nextPoint, fvDimension); //copy the next point to the vector
        free((*nextPoint).imgName); //clean vectors that will be recreated inside readPoint function
        free((*nextPoint).assignment);
        //free((*nextPoint));
        read = readPoint(wordsFile, fvDimension, nextPoint); //always reads new point to nextPoint
        //printPoint(*nextPoint, fvDimension);
    } while ( strcmp((*nextPoint).imgName,points[p].imgName)==0 && read != EOF );
    //while does not change the image name and the file is not at the end
        
    if (p==0 && points[p].x==-1) {
        *imgPoints = 0;
    } else {
        *imgPoints = p+1;
    }
    return points;
}

//write the WSA to the output file
void writeResultsFile(Point p, double **wsa, int fvDimension, FILE *resultsFile) {
    //in the output file, 'id' has the image sequential id in the file
    //'x' has the number of points in the image
    //the values of y, a, b, c are simply zero
    int i, j;
    fprintf(resultsFile, "%ld %s ", p.id, p.imgName);
    if (p.x == -1) { //image with no points...
        fprintf(stderr, "Warning: image %s (%ld) has no points! Moving on to the next image...\n", p.imgName, p.id);
        fprintf(resultsFile, "-1\n"); 
    } else {
        //fprintf(resultsFile, "%.5lf %.5lf %.5lf %.5lf %.5lf ", p.x, p.y, p.scale, p.b, p.c);
        fprintf(resultsFile, "%.0lf 0 0 0 0 ", p.x);
        for (i=0; i<fvDimension; i++) { //for each visual word
            for (j=0; j<N_QUADRANTS; j++) { //for each of the quadrant values
                if (wsa[i][j] >= 0.001)  { //consider only significative values
                    if (wsa[i][j]==1.0) fprintf(resultsFile, "1.0 ");
                    else                fprintf(resultsFile, "%lf ", wsa[i][j]);
                } else {
                    fprintf(resultsFile, "0 ");   
                }
            }
        }
        fprintf(resultsFile, "\n");
    }
}

/* Main function */
int main(int argc, char *argv[]) {
    // Parameters usage help                0      1       2           3                4
    const char * const usage = "Usage: wsa <k> <wordsFile> <resultsFile>";

    // If there are too few or too many parameters, prints usage help and exits
    if (argc != 4) {
        fprintf(stderr, "%s\n", usage);
        fprintf(stderr, "<k>\t\t\tdictionary size (number of visual words or centers)\n"); //this parameter is not really necessary (as this info is in the header of the input files), but it helps for avoiding running WSA with wrong files
        fprintf(stderr, "<wordsFile>\t\tfile resulting from the coding/assignment step (hard, soft, etc)\n");
        fprintf(stderr, "<resultsFile>\t\tfile that will store the results (same format as the wordsFile)\n");
        return 1;
    }

    //local variables--------
    int k=-1, i, j, w, quadrant;
    FILE *wordsFile=NULL, *resultsFile=NULL;
    int totalFiles=0, fvDimension=0, imgPoints=0;
    long int nPoints=0;
    Point *points=NULL, nextPoint; //struct variable to store the data from one point
    double **wsa=NULL, sum; //vector to store the counters of each quadrant;

    //progress manager variables
    int imgCounter=0;
    float currProgress=0.0, lastProgress=0.0, progressInterval=0.05;
    clock_t timeIni, timeEnd;
    //------------------------

    //------- INPUT ARGUMENTS -----------------
    k = atoi(argv[1]);
    if (k <= 0) {
        fprintf(stderr, "%s\n", usage);
        fprintf(stderr, "\nk must be a positive integer value! Also, the VECTOR in the wordsFile must have k positions\n");
        return 1;
    }

    wordsFile = fopen(argv[2], "rt");
    if (wordsFile == NULL) {
        fprintf(stderr, "Error %d opening words assignment file %s!\n", errno, argv[2]);
        return 1;
    }
    
    resultsFile = fopen(argv[3], "wt");
    if (resultsFile == NULL) {
        fprintf(stderr, "Error %d creating results file %s!\n", errno, argv[3]);
        return 1;
    }
    //----------------------------------------
    
    //------- READING HEADERS - wordsFile -----
    char keyPointsText[25], keyPointsText2[50];
    fscanf(wordsFile, "%s %s", keyPointsText, keyPointsText2); //skip "KEYPOINTS DETECTOR.DESCRIPTOR"
    fscanf(wordsFile, "%d", &totalFiles);
    fscanf(wordsFile, "%ld", &nPoints);
    if (nPoints <= 0) {
        fprintf(stderr, "Number of points in the wordsFile (%ld) is invalid! It must be a positive integer value!\n", nPoints);
        return 1;
    }
    fscanf(wordsFile, "%d", &fvDimension);
    if (fvDimension != k) {  
        fprintf(stderr, "Vector dimension (%d) must be equal to k (%d)!\n", fvDimension, k);
        return 1;
    }    
    char temp[10]; for (i=0; i<8; i++) fscanf(wordsFile, "%s", temp);  //skip the "ID IMAGE X Y A B C VECTOR" string
    //----------------------------------------

    //----- resultsFile HEADER ---------------
    fprintf(resultsFile, "%s %s\n", keyPointsText, keyPointsText2); //copy the header to the resultsFile
    fprintf(resultsFile, "%d\n%d\n%d\n", totalFiles, totalFiles, (fvDimension*N_QUADRANTS));  //fvDimension==k*N_QUADRANTS
    fprintf(resultsFile, "ID IMAGE X Y A B C VECTOR\n");
    //----------------------------------------

    fprintf(stderr, "WSA (Word Spatial Arrangement) -----------------\n");
    fprintf(stderr, "Dictionary size = %d\n", k);
    fprintf(stderr, "Number of points in the wordsFile file = %ld\n", nPoints);

    //specific value for the first point ever
    nextPoint.id = -11;

    imgCounter = 0;

    fprintf(stderr, "STARTING...\n");
    do {
        //reseting loop variables
        imgPoints = 0;

        timeIni = clock();
        fprintf(stderr, "Loading images points...\t");
        points = loadImagePoints(wordsFile, fvDimension, &nextPoint, &imgPoints); //load all points from the current image
        fprintf(stderr, "%s\timgPoints=%d\tok!\n", points[0].imgName, imgPoints);
        //printPoint(nextPoint, fvDimension);
        timeEnd = clock();
        fprintf(stderr, ">>time[LOAD IMG POINTS]: %f\n", (float) (timeEnd - timeIni)/CLOCKS_PER_SEC);

        //create the WSA descriptor -- 4 values for each visual word! (N_QUADRANTS values, in fact)
        wsa = (double **) calloc(k, sizeof(double *));
        for(w=0; w<k; w++) {
            wsa[w] = (double *) calloc(N_QUADRANTS, sizeof(double));
        }

        if (imgPoints != 0) { //image has points
                              //imgPoints=0 for images without points
            fprintf(stderr, "\tComputing WSA...\n");
            //printf("Point %d ->\t%lf, %lf\n", p, points[p].x, points[p].y);
            //---------------------------------------------------------------------
            //----- WSA ITSELF ---------
            for (i=0; i<imgPoints; i++) {
                //timeIni = clock();
                for (j=0; j<imgPoints; j++) {
                    if (i != j) { //only consider different points... the point is not compared against itself

                        //verify to each quadrant j point belongs  (i is the origin of the quadrants)
                        // (0,0) <--x-->     (xmax,0)
                        //          |
                        // ^     1  |  0             0 --> j.x >= i.x && j.y <= i.y
                        // y ______(i)______         1 --> j.x <  i.x && j.y <= i.y
                        // ,        |                2 --> j.x <  i.x && j.y >  i.y
                        //       2  |  3             3 --> j.x >= i.x && j.y >  i.y
                        //          |
                        // (0,ymax)         (xmax,ymax)
                        //find the quadrant to be incremented
                        if (points[j].x >= points[i].x && points[j].y <= points[i].y) {
                            quadrant = 0;   //0 correspond to the quadrant 0 in the illustration above
                        } else if (points[j].x < points[i].x && points[j].y <= points[i].y) {
                            quadrant = 1;   //1 correspond to the quadrant 1 in the illustration above
                        } else if (points[j].x < points[i].x && points[j].y > points[i].y) {
                            quadrant = 2;   //2 correspond to the quadrant 2 in the illustration above
                        } else if (points[j].x >= points[i].x && points[j].y > points[i].y) {
                            quadrant = 3;   //3 correspond to the quadrant 3 in the illustration above
                        } else {
                            fprintf(stderr, "\tERROR!! It should not arrive here!!!\n");
                            exit(1);
                        }

                        //fprintf(stderr, "point %d (%d,%d) is in quadrant %d in relation to point %d (%d,%d)\n", j, (int)points[j].x, (int)points[j].y, quadrant, i, (int)points[i].x, (int)points[i].y);
                        
                        //increment the quadrant proportionally to the activation/assignment of the point to the each visual word
                        for (w=0; w<k; w++) {
                            //increment the corresponding quadrant of word w by an amount proportionally to the point assignment to w
                            if (points[j].assignment[w] > THRESHOLD_SOFT) {  //increment only assignment values greater than THRESHOLD_SOFT
                                wsa[w][quadrant] += points[j].assignment[w]; //in the case of HARD assignment, only 1 word will be incremented
                            }
                        }
                    }
                }
                //timeEnd = clock();
                //fprintf(stderr, ">>time[ONE WSA RUN]: %f\n", (float) (timeEnd - timeIni)/CLOCKS_PER_SEC);
            }
            
            //normalizing WSA per matrix --> the 4 values of each line, sum 1.0
            int nActiveWords=k;
            for (w=0; w<k; w++) {
                sum = 0;
                //summing the quadrants values...
                for (i=0; i<N_QUADRANTS; i++) {
                    sum += wsa[w][i]; //cumulate the values of all quadrants
                }
                if (sum == 0) nActiveWords--; //count how many words are not present in the image
                //normalizing WSA by the sum...
                for (i=0; i<N_QUADRANTS; i++) {
                    wsa[w][i] = wsa[w][i] / sum;
                }
            }
            fprintf(stderr, "\tnActiveWords=%d\n", nActiveWords);
            //----- WSA ITSELF  - end ---
            //---------------------------------------------------------------------
        }
        
        points[0].x = imgPoints; //put in the X value, the number of points in the current image
        points[0].id = imgCounter+1; //put in the id value, the image number in the file sequence
        writeResultsFile(points[0], wsa, k, resultsFile);

        //clear the WSA vector -- the next image must have an empty vector of counters
        for(w=0; w<k; w++) {
            free(wsa[w]);
        }
        free(wsa);
                
        //clear the point vector
        for (i=0; i<MAX_POINTS; i++) {
            free(points[i].imgName); 
            free(points[i].assignment);
        }
        free(points);

        //update the progress
        imgCounter++;
        currProgress = imgCounter/(float)totalFiles;
        if ( (currProgress - lastProgress) >= progressInterval ) {
            lastProgress = currProgress;
            printf("Progress: %f\n", currProgress);
        }        
        
    } while (!feof(wordsFile));
    
    fprintf(stderr, "Success!\n");

    //free memory
    //printf("nextPoint.id=%ld\n", nextPoint.id);
    free(nextPoint.imgName);
    free(nextPoint.assignment);

    // Closes files
    fclose(wordsFile);
    fclose(resultsFile);
    
    return 0;
}
